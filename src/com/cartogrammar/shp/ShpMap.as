package com.cartogrammar.shp{    import flash.display.DisplayObject;  import flash.display.Sprite;  import flash.events.Event;  import flash.events.MouseEvent;  import flash.geom.Rectangle;  import flash.net.URLLoader;  import flash.net.URLLoaderDataFormat;  import flash.net.URLRequest;  import flash.utils.ByteArray;  import flash.utils.Dictionary;    import org.vanrijkom.dbf.*;  import org.vanrijkom.shp.*;    /**   * The ShpMap class represents a map drawn from a single shapefile.   * This class currently supports basic point, polyline, and polygon shapefiles.   * @author Andy Woodruff (http://www.cartogrammar.com/blog);   *    */  public class ShpMap extends Sprite{        /**     * The geographic (e.g. states or countries) features contained in the shapefile.     */    public var features : Array = new Array();        public var attributeFields : Array;    public var censusData : Dictionary;    //public var changePopulation : Dictionary;        /**     * A Sprite on which features will be added. This exists so that it can be positioned correctly within the ShpMap.     */    private var map : Sprite = new Sprite();        private var dataLoader : URLLoader = new URLLoader();    private var shpLoaded : Boolean = false;        // string variables per county for tooltip passing purposes.    // gets passed to ShpMapObject through event handler, then from there to RuralWestPop    private var prevCounty : String = "a";    private var curCounty : String = "b";    private var area : String = "";    private var population : String = "";    private var change : String = "";    private var state : String = "";    private var fips : String = "";    private var age17: String = "";    private var age20: String = "";    private var age44: String = "";    private var age65: String = "";    private var edu18: String = "";    private var density: String = "";    private var percent: String = "";        private var border : Boolean = true;        /**     * Constructor     * @param src A String giving the location of the source shapefile.     * @param dbfSrc (optional) A string giving the location of the DBF file associated with the shapefile     */    public function ShpMap( src : String, dbfSrc : String = null,                             censusData : Dictionary = null)    {            addChild(map);      this.censusData = censusData;      //this.changePopulation = changePopulation;            // load the shapefile            dataLoader.dataFormat = URLLoaderDataFormat.BINARY;      dataLoader.load( new URLRequest(src) );      dataLoader.addEventListener( Event.COMPLETE, onShapefile );            if ( dbfSrc != null ) {        var dbfLoader : URLLoader = new URLLoader();        dbfLoader.dataFormat = URLLoaderDataFormat.BINARY;        dbfLoader.load( new URLRequest(dbfSrc) );        dbfLoader.addEventListener( Event.COMPLETE, onDBF );      }    }        private function onShapefile( event:Event ) : void    {            // use the ShpTools class to parse the shapefile into an array of records      var records : Array = ShpTools.readRecords(event.target.data).records;            // create a feature (point, polyline, or polygon) from each record      for each( var record : ShpRecord in records ){        var feature : ShpFeature = createFeature(record);        if ( feature != null ) features.push( feature );      }            shpLoaded = true;            // draw the features      drawMap();            // to signal the completion of map loading/drawing      dispatchEvent(new Event("map loaded",true));    }        /**     * Creates the appropriate type of feature for a record.     * @param record The source record.     * @return A point, polyline, or polygon feature.     *      */    private function createFeature( record : ShpRecord ) : ShpFeature    {      var feature : ShpFeature;      switch( record.shapeType ) {                case ShpType.SHAPE_POINT:        feature = new PointFeature(record);        break;                case ShpType.SHAPE_POLYLINE:        feature = new PolylineFeature(record);        break;                case ShpType.SHAPE_POLYGON:        feature = new PolygonFeature(record);        break;              }            // other shape types will return null      return feature;    }        // Event handler for DBF load.    private function onDBF( event:Event ) : void    {      // Wait to create attributes until the shapefile is loaded.      if (shpLoaded){        createAttributes(event.target.data);      } else {        dataLoader.addEventListener( Event.COMPLETE, function(e:Event):void{ createAttributes(event.target.data); } );      }    }        private function createAttributes( dbf : ByteArray ) : void    {      var dbfHeader : DbfHeader = new DbfHeader(dbf);            // Checking if the DBF has the same number of records as the shapefile is a basic test of whether the two files match.      if (dbfHeader.recordCount != features.length) {        throw new Error("Shapefile/DBF record count mismatch. Attributes were not loaded.");        return;      }            // Populate attribute field names array.      attributeFields = new Array();      for each ( var field : DbfField in dbfHeader.fields ) {        attributeFields.push( field.name );      }            for ( var i : int = 0; i < features.length; i++ ) {        features[i].values = DbfTools.getRecord(dbf,dbfHeader,i).values;        features[i].addEventListener(MouseEvent.MOUSE_OVER,  displayCountyInfo);        features[i].addEventListener(MouseEvent.ROLL_OUT, removeCountyInfo);      }            //TODO: now use hard coded value...      updateMapColor("population");            dispatchEvent(new Event("attributes loaded",true));          }         public function updateMapColor(showMode:String):void {    	      // Assign attribute dictionaries to features.      for ( var i : int = 0; i < features.length; i++ ) {        if (!features[i].values) {          trace(i);          continue;        }        fips = trim(features[i].values["ID"]);        if (showMode == "none") {          features[i].draw(0xbbbbbb, 0x444444, 0);        } else if (showMode == "percapita_physicians") {          if (fips.length >0 && censusData.hasOwnProperty(fips)) {            //var value:Number = censusData[fips].total;			trace("$updateMapColor$");			var value:Number = censusData[fips].numPhys / censusData[fips].numPop;			trace(value);            if (value >= 0.01) {              var color:uint = 0xBD0026;              } else if (value >= 0.005) {              color = 0xF03B20;              } else if (value >= 0.001) {              color = 0xFD8D3C;              } else if (value >= 0.0005) {              color = 0xFEB24C;              } else if (value >= 0.0002) {              color = 0xFED976;              } else if (value >= 0) {              color = 0xFFFFB2;            } else {              color = 0xcccccc;            }          } else {            color = 0xaaaaaa;          }          if(border)            features[i].draw(0x444444, color);          else            features[i].draw(color, color);        }        else if (showMode == "population") {          if (fips.length >0 && censusData.hasOwnProperty(fips)) {            var value:Number = censusData[fips].total;            if (value >= 100000) {              var color:uint = 0xBD0026;              } else if (value >= 50000) {              color = 0xF03B20;              } else if (value >= 20000) {              color = 0xFD8D3C;              } else if (value >= 10000) {              color = 0xFEB24C;              } else if (value >= 5000) {              color = 0xFED976;              } else if (value >= 0) {              color = 0xFFFFB2;            } else {              color = 0xcccccc;            }          } else {            color = 0xaaaaaa;          }          if(border)            features[i].draw(0x444444, color);          else            features[i].draw(color, color);                } else if (showMode == "density") {          if (fips.length >0 && int(features[i].values["AREA"]) > 0 && censusData.hasOwnProperty(fips)) {            value = censusData[fips].total / int(features[i].values["AREA"])            if (value >= 50) {              color = 0x253494;            } else if (value >= 20) {              color = 0x2C7FB8;            } else if (value >= 10) {              color = 0x41B6C4;            } else if (value >= 5) {              color = 0x7FCDBB;            } else if (value >= 2) {              color = 0xC7E9B4;            } else if (value >= 0) {              color = 0xFFFFCC;            } else {              color = 0xcccccc;            }          } else {            color = 0xaaaaaa;          }          if(border)            features[i].draw(0x555555, color);          else            features[i].draw(color, color);                  } else if (showMode == "percent"){          if (fips.length >0 && censusData.hasOwnProperty(fips)) {            value = censusData[fips].total / censusData["100000"].total;            if (value >= 0.005) {              color = 0x6837;            } else if (value >= 0.002) {              color = 0x31a354;            } else if (value >= 0.001) {              color = 0x78c679;            } else if (value >= 0.0005) {              color = 0xaddd8e;            } else if (value >= 0.0002) {              color = 0xd9f0a3;            } else if (value >= 0) {              color = 0xFFFFCC;            } else {              color = 0xcccccc;            }          } else {            color = 0xaaaaaa;          }          if(border)            features[i].draw(0x555555, color);          else            features[i].draw(color, color);                    } else if (showMode == "change"){          if (fips.length >0 && censusData.hasOwnProperty(fips)) {            if (censusData[fips].change == "N/A") {              color = 0xcccccc;            } else {              value = parseFloat(censusData[fips].change);                            if (value >= 0.5) {                //color = 0x6A51A3;                color = 0x1A9850;              } else if (value >= 0.2) {                //color = 0x9E9AC8;                color = 0x66BD63;              } else if (value >= 0) {                //color = 0xCBC9E2;                color = 0xA6D96A;              } else if (value >= -0.1) {                //color = 0xDEEBF7;                color = 0xFDAE61;              } else if (value >= -0.2) {                //color = 0x9ECAE1;                color = 0xF46D43;              } else if (value < -0.2) {                //color = 0x3182BD;                color = 0xD73027;              } else {                color = 0xcccccc;              }            }          } else {            color = 0xaaaaaa;          }          if(border)            features[i].draw(0x55555, color);          else{            features[i].draw(color, color);          }                  } else if (showMode == "frontier") {          if (fips.length >0 && int(features[i].values["AREA"]) > 0 && censusData.hasOwnProperty(fips)) {            value = censusData[fips].total / int(features[i].values["AREA"])            if (value < 2 && value > 0) {              color = 0x91CF60;            } else {              color = 0xcccccc;            }          } else {            color = 0xaaaaaa;          }          if(border)            features[i].draw(0x555555, color);          else            features[i].draw(color, color);                } else if (showMode == "age17") {          if (fips.length >0 && censusData.hasOwnProperty(fips)) {            value =  censusData[fips].age17 / censusData[fips].total;            /*              * 0 to 15%              * 16 to 22%              * 23 to 29%              * 30 to 36%              * 37 to 43%              * > 44 %            */            if (value <= 0.15) {              color = 0x1A423F;            } else if (value <= 0.22) {              color = 0x186861;            } else if (value <= 0.29) {              color = 0x1B9472;            } else if (value <= 0.36) {              color = 0x22C683;            } else if (value <= 0.43) {              color = 0x68F1A5;            } else if (value <= 1.0) {              color = 0xC3FFDE;            } else {              color = 0xaaaaaa;            }          } else {            color = 0xaaaaaa;          }          if(border)            features[i].draw(0x555555, color);          else            features[i].draw(color, color);                  } else if (showMode == "age20") {          if (fips.length >0 && censusData.hasOwnProperty(fips)) {            value =  censusData[fips].age20 / censusData[fips].total;            /*              * 0 to 15%              * 16 to 22%              * 23 to 29%              * 30 to 36%              * 37 to 43%              * > 44 %            */            if (value <= 0.15) {              color = 0x174872;            } else if (value <= 0.22) {              color = 0x1864A4;            } else if (value <= 0.29) {              color = 0x208DCC;            } else if (value <= 0.36) {              color = 0x44C0E3;            } else if (value <= 0.43) {              color = 0x7EE1F2;            } else if (value <= 1.0) {              color = 0xD6FFFF;            } else {              color = 0xaaaaaa;            }          } else {            color = 0xaaaaaa;          }          if(border)            features[i].draw(0x555555, color);          else            features[i].draw(color, color);                    } else if (showMode == "age44") {          if (fips.length >0 && censusData.hasOwnProperty(fips)) {            value =  censusData[fips].age44 / censusData[fips].total;            /*              * 0 to 15%              * 16 to 22%              * 23 to 29%              * 30 to 36%              * 37 to 43%              * > 44 %            */            if (value <= 0.15) {              color = 0x174872;            } else if (value <= 0.22) {              color = 0x1864A4;            } else if (value <= 0.29) {              color = 0x208DCC;            } else if (value <= 0.36) {              color = 0x44C0E3;            } else if (value <= 0.43) {              color = 0x7EE1F2;            } else if (value <= 1.0) {              color = 0xD6FFFF;            } else {              color = 0xaaaaaa;            }          } else {            color = 0xaaaaaa;          }          if(border)            features[i].draw(0x555555, color);          else            features[i].draw(color, color);                    } else if (showMode == "age65") {          if (fips.length >0 && censusData.hasOwnProperty(fips)) {            value =  censusData[fips].age65 / censusData[fips].total;            /*              * 0 to 6%              * 6 to 12%              * 12 to 18%              * 18 to 24%              * 24 to 30%              * 30 to 42%            */            if (value <= 0.06) {              color = 0x5D3614;            } else if (value <= 0.12) {              color = 0x895712;            } else if (value <= 0.18) {              color = 0xA17C14;            } else if (value <= 0.24) {              color = 0xC1AB1A;            } else if (value <= 0.30) {              color = 0xE0D760;            } else if (value <= 1.00) {              color = 0xFFFCD2;            } else {              color = 0xaaaaaa;            }          } else {            color = 0xaaaaaa;          }          if(border)            features[i].draw(0x555555, color);          else            features[i].draw(color, color);                  } else if (showMode == "edu18") {          if (fips.length >0 && censusData.hasOwnProperty(fips)) {            value = censusData[fips].edu18;            /*              * 35 to 100%              * 28 to 35%              * 21 to 28%              * 14 to 21%              * 7 to 14%              * 0 to 7%            */            if (value >= 0.35) {              color = 0x6837;            } else if (value >= 0.28) {              color = 0x31a354;            } else if (value >= 0.21) {              color = 0x78c679;            } else if (value >= 0.14) {              color = 0xaddd8e;            } else if (value >= 0.07) {              color = 0xd9f0a3;            } else if (value >= 0) {              color = 0xFFFFCC;            } else {              color = 0xcccccc;            }          } else {            color = 0xaaaaaa;          }          if(border)            features[i].draw(0x555555, color);          else            features[i].draw(color, color);                  }else if (showMode == "revPopulation") {          if (fips.length >0 && censusData.hasOwnProperty(fips)) {            value = censusData[fips].total;            if (value >= 100000) {              color = 0xFFFFB2;              } else if (value >= 50000) {              color = 0xFED976;              } else if (value >= 20000) {              color = 0xFEB24C;              } else if (value >= 10000) {              color = 0xFD8D3C;              } else if (value >= 5000) {              color = 0xF03B20;              } else if (value >= 0) {              color = 0xBD0026;            } else {              color = 0xcccccc;            }          } else {            color = 0xaaaaaa;          }          if(border)            features[i].draw(0x444444, color);          else            features[i].draw(color, color);                } else if (showMode == "revDensity") {          if (fips.length >0 && int(features[i].values["AREA"]) > 0 && censusData.hasOwnProperty(fips)) {            value = censusData[fips].total / int(features[i].values["AREA"])            if (value >= 50) {              color = 0xFFFFCC;            } else if (value >= 20) {              color = 0xC7E9B4;            } else if (value >= 10) {              color = 0x7FCDBB;            } else if (value >= 5) {              color = 0x41B6C4;            } else if (value >= 2) {              color = 0x2C7FB8;            } else if (value >= 0) {              color = 0x253494;            } else {              color = 0xcccccc;            }          } else {            color = 0xaaaaaa;          }          if(border)            features[i].draw(0x555555, color);          else            features[i].draw(color, color);                    } else if (showMode == "debug") {          // put debug code here          features[i].draw();         } else {          features[i].draw();        }              }    }        private function displayCountyInfo(event:MouseEvent):void {            curCounty = trim(event.currentTarget.values["COUNTY"]);      state = trim(event.currentTarget.values["STATE"]);      area = trim(event.currentTarget.values["AREA"]);      fips = trim(event.currentTarget.values["ID"]);                  if(censusData.hasOwnProperty(fips) && parseInt(fips) >0) {          population = censusData[fips].total.toString()                if (parseInt(population) > 0) {          percent= (Math.round(parseInt(population)/censusData["100000"].total*100000)/1000).toString() + " %";          age17 = (Math.round(parseInt(censusData[fips].age17)/parseInt(population)*1000)/10).toString() + " %";          age20 = (Math.round(parseInt(censusData[fips].age20)/parseInt(population)*1000)/10).toString() + " %";          age44 = (Math.round(parseInt(censusData[fips].age44)/parseInt(population)*1000)/10).toString() + " %";          age65 = (Math.round(parseInt(censusData[fips].age65)/parseInt(population)*1000)/10).toString() + " %";          edu18 = (Math.round(parseFloat(censusData[fips].edu18)*1000)/10).toString() + " %";        }                if (censusData[fips].change != "N/A") {          change = (Math.round(parseFloat(censusData[fips].change)*1000)/10).toString() + " %";        } else {          change = "N/A";        }                if (parseInt(area) > 0) {          density = (Math.round(parseInt(population)/parseFloat(area)*100)/100).toString();        } else {          density = "N/A";        }              } else {        population = "N/A";        percent = "N/A";        change = "N/A";        age17 = "N/A";        age20 = "N/A";        age44 = "N/A";        age65 = "N/A";        edu18 = "N/A";        density = "N/A";      }            if(curCounty != prevCounty)        dispatchEvent(new Event(Event.CHANGE));            prevCounty = curCounty;    }        private function removeCountyInfo(event:MouseEvent):void {      curCounty = "";       state = "";      area = "";      population = "";      change = "";      age17 = "";      age20 = "";      age44 = "";      age65 = "";      edu18 = "";      density = "";      percent = "";      dispatchEvent(new Event(Event.CHANGE));    }        public function getCountyName():String{      return curCounty;    }    public function getPopulation():String{      return population;    }        public function getChange():String{      return change;    }        public function getArea():String{      return area;    }    public function getState():String{      return state;    }        public function getAge17():String {      return age17;    }        public function getAge20():String {      return age20;    }        public function getAge44():String {      return age44;    }        public function getAge65():String {      return age65;    }        public function getEdu18():String {      return edu18;    }        public function getDensity():String {      return density;    }        public function getPercent():String {      return percent;    }        /**     * Retrieves a feature from the shapefile based on a specified attribute name and value.     * This is meant for searching unique identifiers. If the field being searched has non-unique      * values, this method will only return the first encountered feature with a matching <code>value</code>.     * @param key The attribute field name.     * @param value  The attribute value.     * @return The feature with the value <code>value</code> for the specified <code>key</code>, or <code>null</null> if no match is found or the <code>key</code> is invalid.     *      */    public function getFeatureByAttribute( key : String, value : * ) : ShpFeature    {      if ( attributeFields.indexOf( key ) == -1 ) return null;  // Fail if there is no such attribute name.      for each ( var feature : ShpFeature in features ) {        if ( feature.values[key] is String ) {          var attribute : String = trim(feature.values[key]);        } else {          attribute = feature.values[key];        }                if ( attribute == value ) return feature;              }      return null;    }        // trims whitespace    private function trim(str:String) : String {      return str.replace(/^\s+|\s+$/g, '');    }        /**     * Adds all the features to the display.      *      */    private function drawMap() : void     {      for each ( var feature : ShpFeature in features ) {        map.addChild(feature);      }            /*  Features are all positioned according to their lat/long,        meaning that x is somewhere from -180 to 180 and y is        between -90 and 90. Here we get the actual bounds of all        features and move the whole map so that its top left        is at the normal (0,0) of Flash coordinate space. */      var bounds : Rectangle = map.getBounds(this);      map.x = -bounds.left;      map.y = -bounds.top;    }        /**     * Adds a given marker at a specified lat/long location.     * A simple demonstration of how the everything is still geo-referenced.     * @param lat The latitude at which to add the marker.     * @param lon The longitude at which to add the marker.     * @param marker The marker to add to the map.     *      */    public function addMarker( lat : Number, lon : Number, marker : DisplayObject ) :void    {      marker.x = lon;      marker.y = -lat;  // remember that negative is UP in Flash but DOWN in latitude! hence the switch here and elsewhere      map.addChild(marker);    }        public function getBorder( inbool:Boolean ):void{      border = inbool;    }      }  }